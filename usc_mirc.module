<?php

function usc_mirc_perm() {
  return array(
    'access mezzanines'
  );
}

function usc_mirc_islandora_content_model_forms_get_transforms() {
  $p = drupal_get_path('module', 'usc_mirc') . '/transforms';
  return array(
    "$p/eaccpf_to_dc.xsl" => "eaccpf_to_dc.xsl (usc_mirc)",
    "$p/pbcore_to_dc.xsl" => "pbcore_to_dc.xsl (usc_mirc)"
  );
}

function usc_mirc_theme() {
  return array(
    'usc_mirc_item' => array(
      'arguments' => array('element' => NULL)
    )
  );
}

function theme_usc_mirc_item($element) {
  //dsm($element);
  $map = $element['#user_data'];
  $pbcore = $map['pbcore'];
  
  //Obtain a traversable list of contexts
  $context = array($pbcore->document->documentElement);
  if (!empty($map['context_xpath'])) {
    $context = $pbcore->query($map['context_xpath']);
  }

  $temp = array();
  foreach ($context as $con) {
    $results = $pbcore->query($map['xpath'], $con);
    
    foreach($results as $result) {
      //dsm($result, 'result');
      $text = $result->textContent;
      if (!empty($text)) {
        $temp[] = $text;
      }
    }
  }
  
  if (count($temp) === 1) {
    $element['#value'] = $temp[0];
  } 
  elseif (count($temp) > 1) {
    $element['#value'] = theme('item_list', $temp);
  }
  
  if (!empty($element['#value'])) {
    return theme('form_element', $element, $element['#value'] . (!empty($element['#children']) ? $element['#children'] : ''));
  }
}
/**
 * php functions used in XPath...
 */
function usc_mirc_create_person_string($name, $role) {
  $output = $name;
  if (!empty($output) && !empty($role)) {
    $output .= " ($role)";
  }
  //dsm($output, 'output');
  return new DOMText($output);
}

function usc_mirc_create_date_string($start, $end) {
  $output = '';
  if (!empty($start) || !empty($end)) {
    if (strcmp($start, $end) === 0) { //They're provided and the same...
      $output = $start;
    }
    else { //At least a partial range
      $output = "$start/$end";
    }
  }
  return new DOMText($output);
}

function usc_mirc_tabs_alter(&$element) {
  //dsm($element);
  
  //Change to the Edit tab if necessary
  $edit =& $element['edit_metadata']['content']['pid'];
  if (!empty($edit)) {
    foreach ($element as $name => &$child) {
      if (strpos($name, '#') === 0) {
        continue;
      }
      elseif ($child['#type'] === 'tabpage') {
        $child['#selected'] = FALSE;
      }
    }
    
    $element['edit_metadata']['#selected'] = TRUE;
  }
  
  //Remove the DC section in 'Object Details' tab...
  //XXX: Relies upon a slight modification in FedoraObjectDetailedContent, which splits up the dc, ds list and purge form into separate children.
  $dc = $element['fedora_object_details']['tabset']['view']['dc'];

  if (!empty($dc) && $dc['#type'] === 'markup') {
    unset($element['fedora_object_details']['tabset']['view']['dc']);
  }
}

/** Duplication of drupal_get_form; however, we exit early so other fun can happen. (Also skip a bit of batch stuff)
 *  "Fun stuff" such as being able to switch tabs based on the contents of the form...  Then again, that could probably be done in the alter function above...  Hmmm...
 */
function _usc_mirc_get_unrendered_form($form_id) {
  $form_state = array(
    'storage' => NULL,
    'submitted' => FALSE,
  );

  $args = func_get_args();
  $cacheable = FALSE;
  
  // If the incoming $_POST contains a form_build_id, we'll check the
  // cache for a copy of the form in question. If it's there, we don't
  // have to rebuild the form to proceed. In addition, if there is stored
  // form_state data from a previous step, we'll retrieve it so it can
  // be passed on to the form processing code.
  if (isset($_POST['form_id']) && $_POST['form_id'] == $form_id && !empty($_POST['form_build_id'])) {
    $form = form_get_cache($_POST['form_build_id'], $form_state);
  }

  // If the previous bit of code didn't result in a populated $form
  // object, we're hitting the form for the first time and we need
  // to build it from scratch.
  if (!isset($form)) {
    $form_state['post'] = $_POST;
    // Use a copy of the function's arguments for manipulation
    $args_temp = $args;
    $args_temp[0] = &$form_state;
    array_unshift($args_temp, $form_id);

    $form = call_user_func_array('drupal_retrieve_form', $args_temp);
    $form_build_id = 'form-' . md5(uniqid(mt_rand(), TRUE));
    $form['#build_id'] = $form_build_id;
    drupal_prepare_form($form_id, $form, $form_state);
    // Store a copy of the unprocessed form for caching and indicate that it
    // is cacheable if #cache will be set.
    $original_form = $form;
    $cacheable = TRUE;
    unset($form_state['post']);
  }
  $form['#post'] = $_POST;

  // Now that we know we have a form, we'll process it (validating,
  // submitting, and handling the results returned by its submission
  // handlers. Submit handlers accumulate data in the form_state by
  // altering the $form_state variable, which is passed into them by
  // reference.
  drupal_process_form($form_id, $form, $form_state);
  if ($cacheable && !empty($form['#cache'])) {
    // Caching is done past drupal_process_form so #process callbacks can
    // set #cache.
    form_set_cache($form_build_id, $original_form, $form_state);
  }

  // Most simple, single-step forms will be finished by this point --
  // drupal_process_form() usually redirects to another page (or to
  // a 'fresh' copy of the form) once processing is complete. If one
  // of the form's handlers has set $form_state['redirect'] to FALSE,
  // the form will simply be re-rendered with the values still in its
  // fields.
  //
  // If $form_state['storage'] or $form_state['rebuild'] has been set
  // and input has been processed, we know that we're in a complex
  // multi-part process of some sort and the form's workflow is NOT
  // complete. We need to construct a fresh copy of the form, passing
  // in the latest $form_state in addition to any other variables passed
  // into drupal_get_form().

  if ((!empty($form_state['storage']) || !empty($form_state['rebuild'])) && !empty($form_state['process_input']) && !form_get_errors()) {
    $form = drupal_rebuild_form($form_id, $form_state, $args);
  }
  
  return $form;
}

function usc_mirc_form_fedora_repository_ingest_form_alter(&$form, &$form_state) {
  if ($form_state['storage']['step'] === 1) {
    if (in_array($form_state['storage']['content_model'], array(
      variable_get('usc_mirc_cmodel_mezzanine', 'usc:test-mezzanine'),
      variable_get('usc_mirc_cmodel_access', 'usc:test-access'),
    ))) {
      $form_state['storage']['pid_namespace'] = variable_get('usc_mirc_namespace', 'usc');
      $form_state['storage']['parent_relation'] = variable_get('usc_mirc_relationship', 'isDerivativeOf');
    }
    
    if ($form_state['storage']['content_model'] === variable_get('usc_mirc_cmodel_mezzanine', 'usc:test-mezzanine')) {
      //TODO: Get a list of instantiations in the parent PBCore
    }
  }
  elseif ($form_state['storage']['step'] === 2) {
    if ($form_state['storage']['content_model'] === variable_get('usc_mirc_cmodel_mezzanine', 'usc:test-mezzanine')) {
      //TODO: Add the of the selected instantiation xml to state/storage/xml_data
    }
  }
}

/**
 *  Get the relevant info...
 */
function _usc_mirc_get_instantiation_array() {
  $toReturn = array(
    'none' => t('')
  );
  
  //1. get the parent PBCore
  //1.1 identify the parent(s)
  module_load_include('inc', 'usc_mirc', 'mezzanine');
  $parents = BaseVideoDisplay::_perform_sparql_query(<<<EOQ
PREFIX fre: <info:fedora/fedora-system:def/relations-external#>
PREFIX fm: <info:fedora/fedora-system:def/model#>
PREFIX fv: <info:fedora/fedora-system:def/view#>
SELECT ?parent
FROM <#ri>
WHERE {
  ?this fre:isDerivativeOf ?parent .
  ?parent fm:state fm:Active ;
          fv:disseminates ?DSs .
  ?DSs fv:disseminationType <info:fedora/*/PBCORE> ;
       fm:state fm:Active .  
}
EOQ
);
  $num_parents = count($parents);
  $parent = NULL;
  
  if ($num_parents > 1) {
    $uri = $parents[0]['parent'];
    $parent = substr($uri, strrpos($uri, '/'));
    watchdog('usc_mirc', 'More than one parent!? Using first (%parent_pid)', array('%parent_pid' => $parent), WATCHDOG_WARNING);
  }
  elseif ($num_parents === 1) {
    $uri = $parents[0]['parent'];
    $parent = substr($uri, strrpos($uri, '/'));
  }
  $pbcore = DOMDocument::load(url("fedora/repository/$parent/PBCORE"));
  if ($pbcore !== FALSE) {  
    $pbcore = new DOMXPath($pbcore);
    //add each instantiation to the array to return.
    $pbcore->registerNamespace('pb', 'http://www.pbcore.org/PBCore/PBCoreNamespace.html');
    foreach ($pbcore->query('//pb:pbcoreInstantiation') as $node) {
      $toReturn[] = 'asdf';
    }
  }
  
  return $toReturn;
}

function usc_mirc_menu() {
  return array(
    'usc/streaming_autocomplete' => array(
      'page callback' => 'usc_mirc_autocomplete_streaming_url',
      'access arguments' => array('access content'),
      'type' => MENU_CALLBACK,
    ),
    'admin/settings/fedora_repository/usc_mirc' => array(
      'title' => t('MIRC Islandora configuration'),
      'description' => t('A number of configuration parameters used in the display of MIRC\'s video collections'),
      'page callback' => 'drupal_get_form',
      'page arguments' => array('usc_mirc_admin_form'),
      'access arguments' => array('administer site configuration'),
      'type' => MENU_LOCAL_TASK,
    ),
  );
}

function usc_mirc_admin_form(&$form_state) {
  $i = -100;
  return system_settings_form(array(
    'usc_mirc_mezzanine_collection' => array(
      '#type' => 'textfield',
      '#weight' => $i++,
      '#title' => t('Top mezzanine collection'),
      '#description' => t('May the same as the top collection of the Islandora config.  Used to populate the list of collections to which a mezzanine may be migrated'),
      '#default_value' => variable_get('usc_mirc_mezzanine_collection', variable_get('fedora_repository_pid', 'usc:mirc')),
    ),
    'usc_mirc_namespace' => array(
      '#type' => 'textfield',
      '#weight' => $i++,
      '#title' => t('MIRC PID namespace'),
      '#description' => t('The namespace/prefix with which new items will be created in Fedora (where a COLLECTION_POLICY doesn\'t already dictate it).'),
      '#default_value' => variable_get('usc_mirc_namespace', 'usc'),
    ),
    'usc_mirc_relationship' => array(
      '#type' => 'textfield',
      '#weight' => $i++,
      '#title' => t('Relationship'),
      '#description' => t('RELS-EXT relationship used to relate mezzanines to VROs and access copies to mezzanines.  Probably a bad idea to change this after objects have already been created, as existing objects will not be changed.'),
      '#default_value' => variable_get('usc_mirc_relationship', 'isDerivativeOf'),
    ),
    'usc_mirc_streaming_url' => array(
      '#type' => 'textfield',
      '#weight' => $i++,
      '#title' => t('Streaming base URL'),
      '#description' => t('URL (possibly with port and path), without a terminiating slash. (Used during access copy autocompletion)'),
      '#default_value' => variable_get('usc_mirc_streaming_url', 'http://dvr-streaming.mirc.sc.edu'),
    ),
    'usc_mirc_streaming_folder' => array(
      '#type' => 'textfield',
      '#weight' => $i++,
      '#title' => t('Streaming folder'),
      '#description' => t('Mountpoint/folder on server under which the streaming access copies are located. (Used during access copy autocompletion)'),
      '#default_value' => variable_get('usc_mirc_streaming_folder', '/mnt/mirc/mezz/access'),
    ),
    'usc_mirc_streaming_extensions' => array(
      '#type' => 'textfield',
      '#weight' => $i++,
      '#title' => t('File extensions'),
      '#description' => t('Space-separated list of h264 file extensions to autocomplete'),
      '#default_value' => variable_get('usc_mirc_streaming_extensions', '.m4v .mp4 .flv .mov'),
    ),
    'cmodels' => array(
      '#type' => 'fieldset',
      '#weight' => $i++,
      '#title' => t('Content Models'),
      '#description' => t('Content Models used for different purposes.  Probably a bad idea to change any after objects have been created with them (existing objects may be orphaned).  Fields may be hidden?'),
      'usc_mirc_cmodel_vro' => array(
        '#type' => 'textfield',
        '#weight' => $i++,
        '#title' => t('VRO Content Model'),
        '#description' => t('Content Model used for Video Resource Objects.'),
        '#default_value' => variable_get('usc_mirc_cmodel_vro', 'usc:test-vro'),
      ),
      'usc_mirc_cmodel_mezzanine' => array(
        '#type' => 'textfield',
        '#weight' => $i++,
        '#title' => t('Mezzanine Content Model'),
        '#description' => t('Content Model used for mezzanine objects.'),
        '#default_value' => variable_get('usc_mirc_cmodel_mezzanine', 'usc:test-mezzanine'),
      ),
      'usc_mirc_cmodel_access' => array(
        '#type' => 'textfield',
        '#weight' => $i++,
        '#title' => t('Access Content Model'),
        '#description' => t('Content Model used for access copy objects.'),
        '#default_value' => variable_get('usc_mirc_cmodel_access', 'usc:test-access'),
      ),
    )
  ));
}

function usc_mirc_redirect_form(&$form_state, $parent_pid) {
  return array(
    'parent_pid' => array(
      '#type' => 'hidden',
      '#value' => $parent_pid,
    ),
    'title' => array(
      '#type' => 'textfield',
      '#title' => t('Object label'),
      '#required' => TRUE,
    ),
    'streaming_url' => array(
      '#type' => 'textfield',
      '#title' => t('Streaming URL'),
      '#required' => TRUE,
      '#autocomplete_path' => 'usc/streaming_autocomplete',
    ),
    'submit' => array(
      '#type' => 'submit',
      '#value' => 'Ingest',
    )
  );
}

function _usc_mirc_get_sub_collections($collection = NULL) {
  if (empty($collection)) { //XXX:  Make into configuration?
    $collection = variable_get('usc_mirc_mezzanine_collection', variable_get('fedora_repository_pid', 'usc:mirc'));
  }
  
  //Get direct children of the collection (with their titles)
  module_load_include('inc', 'usc_mirc', 'mezzanine');
  $results = BaseVideoDisplay::_perform_sparql_query(<<<EOQ
PREFIX fre: <info:fedora/fedora-system:def/relations-external#>
PREFIX fm: <info:fedora/fedora-system:def/model#>
PREFIX dc: <http://purl.org/dc/elements/1.1/>
SELECT ?subcollection ?title
FROM <#ri>
WHERE {
  ?subcollection fre:isMemberOfCollection <info:fedora/$collection> ;
                 fm:state fm:Active ;
                 dc:title ?title .
}
EOQ
);
  $options = array(
    NULL => '(Remove collection association)',
  );
  foreach($results as $result) {
    $options[$result['subcollection']] = $result['title'];
  }
  return $options;
}

function usc_mirc_switch_mezzanine_collection(&$form_state, $object_pid) {
  return array(
    'object_pid' => array(
      '#type' => 'hidden',
      '#value' => $object_pid,
    ),
    'collection' => array(
      '#type' => 'select',
      '#title' => t('New collection'),
      '#description' => t('The collection to which this object should be moved.'),
      '#options' => _usc_mirc_get_sub_collections(),
    ),
    'submit' => array(
      '#type' => 'submit',
      '#value' => t('Move!')
    )
  );
}

function usc_mirc_switch_mezzanine_collection_submit($form, &$form_state) {
  module_load_include('inc', 'fedora_repository', 'api/fedora_item');
  
  $values = $form_state['values'];
  
  $item = new Fedora_Item($values['object_pid']);
  $item->purge_relationship('fedora:isMemberOfCollection', '');
  
  if (!empty($values['collection'])) {
    $item->add_relationship('isMemberOfCollection', $values['collection']);
  }
}

function usc_mirc_redirect_form_submit($form, &$form_state) {
  module_load_include('inc', 'fedora_repository', 'api/fedora_item');
  
  $values = $form_state['values'];
  
  $pid_namespace = variable_get('usc_mirc_namespace', 'usc');
  $pid = Fedora_Item::get_next_PID_in_namespace($pid_namespace);
  
  global $user;
  $new_item = Fedora_Item::ingest_new_item($pid, 'A', $values['title'], $user->name);
  
  $new_item->add_datastream_from_url($values['streaming_url'], 'VIDEO', 'Video Redirect', 'video/mp4', 'R', 'Added from Islandora');
  $new_item->add_relationship(variable_get('usc_mirc_relationship', 'isDerivativeOf'), $values['parent_pid']);
  $new_item->add_relationship('fedora-model:hasModel', variable_get('usc_mirc_cmodel_access', 'usc:test-access'));
}

function _usc_mirc_is_video_filename($filename) {
  static $exts = NULL;
  if (empty($exts)) {
    explode(
      ' ', 
      variable_get(
        'usc_mirc_streaming_extensions',
        '.m4v .mp4 .flv .mov'
      )
    );
  }
  
  return in_array(substr($filename, -4), $exts);
}

/**
 *  Get an array of all the files in this directory (including subdirectories if $recurse is TRUE).
 */
function _usc_mirc_traverse_directory($sub_dir = '.', $recurse = TRUE) {
  //TODO: Make configuration
  static $sb = NULL;
  static $fsb = NULL;
  
  if (empty($sb) || empty($fsb)) {
    $sb = variable_get('usc_mirc_streaming_url', 'http://dvr-streaming.mirc.sc.edu');
    $fsb = variable_get('usc_mirc_streaming_folder', '/mnt/mirc/mezz/access');
  }
  
  $videos = array();
  
  $dir = dir("$fsb/$sub_dir");
  while ($entry = $dir->read()) {
    $this_entry = "$sub_dir/$entry";
    if ($recurse && is_dir("$fsb/$this_entry")) {
      $videos = array_merge($videos, _usc_mirc_traverse_directory($this_entry, $recurse));
    }
    elseif ($string === '*' || strpos($entry, $string) === 0) {
      $videos["$sb/$this_entry"] = $entry;
    }
  }
  $dir->close();
  
  return $videos;
}

function usc_mirc_autocomplete_streaming_url($string) {
  $videos = _usc_mirc_traverse_directory();
  $videos = array_filter($videos, '_usc_mirc_is_video_filename');
  
  ksort($videos);
  drupal_json($videos);

  return;
}

function usc_mirc_islandora_solr_primary_display() {
  return array(
    'usc_mirc_display' => array(
      'name' => t('USC display'),
      'module' => 'usc_mirc',
      'file' => 'SolrResults.inc',
      'class' => 'USC_Results',
      'function' => 'displayResults',
      'description' => t('More specific output.'),
    ),
  );
}
